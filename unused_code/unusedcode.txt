{/* 
const [infoTachas, setinfoTachas] = useState([]);
const fetcher = (...args) => fetch(...args).then(response => response.json());
const { data, error } = useSwr(url, { fetcher });
setinfoTachas([data && !error ? data.slice(0, 100) : []])
*/}

{/*
const [infoTachas, setinfoTachas] = useState([]);
const url = 'https://tachasweb-default-rtdb.firebaseio.com/data.json?print=pretty';

async function retrieveData(){
    const response = await fetch(url);
    const data = await response.json();
    setinfoTachas([data]);
}

retrieveData();

setInterval(retrieveData, 5000);

console.log("Lo que sale de App.js", infoTachas);
*/}

onValue(dbRef, (snapshot) => {
const data = snapshot.val();
});

console.log(data);



const SetBlink = (acel) => {

    const [render, setRender] = useState(true)
    const timerRef = useRef()
    
    const interval = (a) => {
        if ((0 <= a) && (a <= 60)) {
            return 1000
        }
        if ((61 <= a) && (a <= 80)) {
            return 500
        }
        if ((81 <= a) && (a <= 100)) {
            return 250
        }
        else {
            return 1000
        }
    }

    useEffect(() => {
        timerRef.current = setInterval(() => {setRender((r) => !r)}, interval(acel));
        return () => {clearInterval(timerRef.current)}
    },[acel])

    return render;
}


{props.nodos.map(nodo => ( SetBlink(nodo.acelerometro) ? (
                <Circle  
                key={nodo.id}
                center={[nodo.location.latitude, nodo.location.longitude]}
                pathOptions={{color: color_selector(nodo.acelerometro), stroke : false, fillOpacity : 0.9}}
                radius={zoom_converter(zoomLevel)}>
                <Popup>
                    ID: {nodo.id} <br></br>
                    Latitud: {nodo.location.latitude} <br></br>
                    Longitud: {nodo.location.longitude} <br></br>
                    Luz: {nodo.luz}<br></br>
                    Temperatura: {nodo.temperatura}<br></br>
                    Humedad: {nodo.humedad}<br></br>
                    Acelerometro : {nodo.acelerometro} <br></br>
                </Popup>
                <Tooltip direction="bottom" opacity={1} sticky = {true}>
                    ID: {nodo.id} <br></br>
                    Latitud: {nodo.location.latitude} <br></br>
                    Longitud: {nodo.location.longitude} <br></br>
                    Luz: {nodo.luz}<br></br>
                    Temperatura: {nodo.temperatura}<br></br>
                    Humedad: {nodo.humedad}<br></br>
                    Acelerometro : {nodo.acelerometro} <br></br>
                </Tooltip>
            </Circle>) : null ))}



fetch(url, {
  method: 'POST',
  mode: 'no-cors',
  redirect: 'follow',
  headers: new Headers({ 
          'Content-Type': "application/json", 
          'Grpc-Metadata-Authorization': "Bearer " + token, 
  }),
  body: JSON.stringify(body) 
}).then(() => console.log('Se envi贸 informaci贸n por http'));


const options = {
  hostname: "hook.in",
  port: 443,
  path: "/1gmZlwZybZfd6NOO6q89",
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Content-Length": body.length
  }
}

const req = https.request(options, (res) => {
  console.log(`status: ${res.statusCode}`);
});

req.write(body);
req.end();



const url1 = 'http://3.90.212.240:8080/api/devices/2cf7f1203230a466/queue';
const url2 = 'https://hookb.in/eKN1njojygClwQmmw3K8';
const body = JSON.stringify( { "deviceQueueItem": {"confirmed": true, "data": "Ag==", "devEUI": "2cf7f1203230a466", "fCnt": 0, "fPort": 3} } );
const token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhcGlfa2V5X2lkIjoiNDExMzkxZDItMGY0ZC00MTAzLTkwZjAtNDE1NTQ0ZjA4YTljIiwiYXVkIjoiYXMiLCJpc3MiOiJhcyIsIm5iZiI6MTY0MjYxNjIwMCwic3ViIjoiYXBpX2tleSJ9._a7OBvSyrw0z-Gdo36W2SgjoVfe5syE2ZgKsl-13qes";

fetch(url1, {
  method: 'POST',
  mode: 'no-cors',
  headers: {
    'content-type': "application/json", 
    'grpc-metadata-authorization': "Bearer " + token,
    'content-length': body.length 
  },
  body: body,
}).then(() => console.log('Se envi贸 informaci贸n por http'));


'Grpc-Metadata-Authorization': 'Bearer ' + token,