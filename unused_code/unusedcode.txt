{/* 
const [infoTachas, setinfoTachas] = useState([]);
const fetcher = (...args) => fetch(...args).then(response => response.json());
const { data, error } = useSwr(url, { fetcher });
setinfoTachas([data && !error ? data.slice(0, 100) : []])
*/}

{/*
const [infoTachas, setinfoTachas] = useState([]);
const url = 'https://tachasweb-default-rtdb.firebaseio.com/data.json?print=pretty';

async function retrieveData(){
    const response = await fetch(url);
    const data = await response.json();
    setinfoTachas([data]);
}

retrieveData();

setInterval(retrieveData, 5000);

console.log("Lo que sale de App.js", infoTachas);
*/}

onValue(dbRef, (snapshot) => {
const data = snapshot.val();
});

console.log(data);



const SetBlink = (acel) => {

    const [render, setRender] = useState(true)
    const timerRef = useRef()
    
    const interval = (a) => {
        if ((0 <= a) && (a <= 60)) {
            return 1000
        }
        if ((61 <= a) && (a <= 80)) {
            return 500
        }
        if ((81 <= a) && (a <= 100)) {
            return 250
        }
        else {
            return 1000
        }
    }

    useEffect(() => {
        timerRef.current = setInterval(() => {setRender((r) => !r)}, interval(acel));
        return () => {clearInterval(timerRef.current)}
    },[acel])

    return render;
}


{props.nodos.map(nodo => ( SetBlink(nodo.acelerometro) ? (
                <Circle  
                key={nodo.id}
                center={[nodo.location.latitude, nodo.location.longitude]}
                pathOptions={{color: color_selector(nodo.acelerometro), stroke : false, fillOpacity : 0.9}}
                radius={zoom_converter(zoomLevel)}>
                <Popup>
                    ID: {nodo.id} <br></br>
                    Latitud: {nodo.location.latitude} <br></br>
                    Longitud: {nodo.location.longitude} <br></br>
                    Luz: {nodo.luz}<br></br>
                    Temperatura: {nodo.temperatura}<br></br>
                    Humedad: {nodo.humedad}<br></br>
                    Acelerometro : {nodo.acelerometro} <br></br>
                </Popup>
                <Tooltip direction="bottom" opacity={1} sticky = {true}>
                    ID: {nodo.id} <br></br>
                    Latitud: {nodo.location.latitude} <br></br>
                    Longitud: {nodo.location.longitude} <br></br>
                    Luz: {nodo.luz}<br></br>
                    Temperatura: {nodo.temperatura}<br></br>
                    Humedad: {nodo.humedad}<br></br>
                    Acelerometro : {nodo.acelerometro} <br></br>
                </Tooltip>
            </Circle>) : null ))}



fetch(url, {
  method: 'POST',
  mode: 'no-cors',
  redirect: 'follow',
  headers: new Headers({ 
          'Content-Type': "application/json", 
          'Grpc-Metadata-Authorization': "Bearer " + token, 
  }),
  body: JSON.stringify(body) 
}).then(() => console.log('Se envió información por http'));


const options = {
  hostname: "hook.in",
  port: 443,
  path: "/1gmZlwZybZfd6NOO6q89",
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Content-Length": body.length
  }
}

const req = https.request(options, (res) => {
  console.log(`status: ${res.statusCode}`);
});

req.write(body);
req.end();



const url1 = 'http://3.90.212.240:8080/api/devices/2cf7f1203230a466/queue';
const url2 = 'https://hookb.in/eKN1njojygClwQmmw3K8';
const body = JSON.stringify( { "deviceQueueItem": {"confirmed": true, "data": "Ag==", "devEUI": "2cf7f1203230a466", "fCnt": 0, "fPort": 3} } );
const token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhcGlfa2V5X2lkIjoiNDExMzkxZDItMGY0ZC00MTAzLTkwZjAtNDE1NTQ0ZjA4YTljIiwiYXVkIjoiYXMiLCJpc3MiOiJhcyIsIm5iZiI6MTY0MjYxNjIwMCwic3ViIjoiYXBpX2tleSJ9._a7OBvSyrw0z-Gdo36W2SgjoVfe5syE2ZgKsl-13qes";

fetch(url1, {
  method: 'POST',
  mode: 'no-cors',
  headers: {
    'content-type': "application/json", 
    'grpc-metadata-authorization': "Bearer " + token,
    'content-length': body.length 
  },
  body: body,
}).then(() => console.log('Se envió información por http'));


'Grpc-Metadata-Authorization': 'Bearer ' + token,



{/*
const url = 'http://3.90.212.240:8080/api/devices/2cf7f1203230a466/queue';
const body = JSON.stringify({"deviceQueueItem": {"confirmed": true, "data": "Ag==", "devEUI": "2cf7f1203230a466", "fCnt": 0, "fPort": 3}});
const token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhcGlfa2V5X2lkIjoiNDExMzkxZDItMGY0ZC00MTAzLTkwZjAtNDE1NTQ0ZjA4YTljIiwiYXVkIjoiYXMiLCJpc3MiOiJhcyIsIm5iZiI6MTY0MjYxNjIwMCwic3ViIjoiYXBpX2tleSJ9._a7OBvSyrw0z-Gdo36W2SgjoVfe5syE2ZgKsl-13qes";

fetch(url, {
  method: 'POST',
  body: body,
  headers: {
      'Content-Type': 'application/json',
      'Grpc-Metadata-Authorization': 'Bearer ' + token,
  }
  }).then(res => res.json())
  .catch(error => console.error('Error:', error))
  .then(response => console.log('Success:', response));     
*/}

// Bloque de código para comunicarse con ChirpStack mediante POST request
{/*
const url = 'https://sunandchirpstack.ddns.net:8080/api/devices/2cf7f1203230a466/queue';
const body = JSON.stringify({
                              "deviceQueueItem": 
                                {
                                  "confirmed": true, 
                                  "data": "Ag==", 
                                  "devEUI": "2cf7f1203230a466", 
                                  "fCnt": 0, "fPort": 3
                                }
                            });
const token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhcGlfa2V5X2lkIjoiNDExMzkxZDItMGY0ZC00MTAzLTkwZjAtNDE1NTQ0ZjA4YTljIiwiYXVkIjoiYXMiLCJpc3MiOiJhcyIsIm5iZiI6MTY0MjYxNjIwMCwic3ViIjoiYXBpX2tleSJ9._a7OBvSyrw0z-Gdo36W2SgjoVfe5syE2ZgKsl-13qes";

fetch(url, {
  method: "POST",
  body: body,
  headers: 
    {
      "Content-Type": "application/json",
      "Grpc-Metadata-Authorization": "Bearer " + token,
    }
}).then((response) => response.json())
.then((data) => {
  console.log('Success:', data);
}) 
.catch((error) => {
  console.log('Error:', error);
})
*/}



function colorTacha (color) {
    
    switch (color) 
    {
        case 'gray':
            setColor('green')
            break;
        case 'green':
            setColor('yellow')
            break;
        case 'yellow':
            setColor('red')
            break;
        default:
            setColor('green')
            break;
    }
}





import * as grpc from '@grpc/grpc-js';

import * as internalService from '@chirpstack/chirpstack-api/as/external/api/internal_grpc_pb';
import * as internalMessages from '@chirpstack/chirpstack-api/as/external/api/internal_pb';

// Create the client for the 'internal' service
const internalServiceClient = new internalService.InternalServiceClient(
    'localhost:8080',
    grpc.credentials.createInsecure()
);

// Create and build the login request message
const loginRequest = new internalMessages.LoginRequest();

loginRequest.setEmail('email');
loginRequest.setPassword('password');

// Send the login request
internalServiceClient.login(loginRequest, (error, response) => {
    // Build a gRPC metadata object, setting the authorization key to the JWT we
    // got back from logging in.
    const metadata = new grpc.Metadata();
    metadata.set('authorization', response.getJwt());

    // This metadata can now be passed for requests to APIs that require authorization
    // e.g.
    // deviceServiceClient.create(createDeviceRequest, metadata, callback);
});


lista.forEach(id => {
    set(ref(db, 'downlink/' + id), {
        color : color
    });
})


<Marker
    icon={color_selector(tacha.temperatura)}
    //key={tacha.id}
    position={[tacha.location.latitud, tacha.location.longitud]}
    //center={[tacha.location.latitud, tacha.location.longitud]}
    //pathOptions={{color: color_selector(tacha.temperatura), stroke : false, fillOpacity : 1.0}}
    //radius={zoom_converter(zoomLevel)}
    >

<MarkerClusterGroup disableClusteringAtZoom={13} maxClusterRadius={60} singleMarkerMode={false}>
  <Circle  
    key={tacha.id}
    center={[tacha.location.latitud, tacha.location.longitud]}
    pathOptions={{color: color_selector(tacha.humedad), stroke : false, fillOpacity : 1.0}}
    radius={zoom_converter(zoomLevel)}>
    <Popup closeOnClick={false}>
        ID: {tacha.id} <br></br>
        Latitud: {tacha.location.latitud} <br></br>
        Longitud: {tacha.location.longitud} <br></br>
        Luz: {tacha.luz}<br></br>
        Temperatura: {tacha.temperatura}<br></br>
        Humedad: {tacha.humedad}<br></br>
        Acelerometro : {tacha.acelerometro} <br></br>
    </Popup>
    <Tooltip direction="bottom" opacity={1} sticky = {true}>
        ID: {tacha.id} <br></br>
        Latitud: {tacha.location.latitud} <br></br>
        Longitud: {tacha.location.longitud} <br></br>
        Luz: {tacha.luz}<br></br>
        Temperatura: {tacha.temperatura}<br></br>
        Humedad: {tacha.humedad}<br></br>
        Acelerometro : {tacha.acelerometro} <br></br>
    </Tooltip>
  </Circle>
</MarkerClusterGroup>


<div className={classes.MainDiv}>

    <Link to="/">Página principal</Link>

    <div className={classes.LineChartPlot}>
        <LineChartPlot></LineChartPlot>
    </div>
    
    <div className={classes.ScatterChartPlot}>
        <ScatterChartPlot></ScatterChartPlot>
    </div>
    
    <div className={classes.VerticalBarPlot}>
        <VerticalBarPlot></VerticalBarPlot>
    </div>

    <div className={classes.PieChartPlot}>
        <PieChartPlot></PieChartPlot>
    </div>
    
</div>


.LineChartPlot {
    width: 50%;
    height: 50%;
    background-color: lightgray;
}

.ScatterChartPlot {
    width: 50%;
    margin-left: 50%;
    height: 50%;
    margin-top: -82%;
    background-color: lightgray;
}

.VerticalBarPlot {
    width: 50%;
    height: 25vh;
    margin-top: 0vh;
    background-color: lightgray;
}

.PieChartPlot {
    width: 50%;
    margin-left: 50%;
    height: 50%;
    margin-top: -50%;
    background-color: lightgray;
}


ID: {tacha.id} <br></br>
Latitud: {tacha.location.latitud} <br></br>
Longitud: {tacha.location.longitud} <br></br>
Luz: {tacha.luz}<br></br>
Temperatura: {tacha.temperatura}<br></br>
Humedad: {tacha.humedad}<br></br>
Acelerometro : {tacha.acelerometro} <br></br>


var newLine = "\r\n"
var msg = "Los datos ingresados son incorrectos:"
msg += newLine;
msg += "-> Las ids ingresadas no son números válidos";
msg += newLine;
msg += "-> Los rangos no son correctos (deben ser de menor a mayor)";
msg += newLine;
msg += "-> No hay un color seleccionado o hay más de uno";
alert(msg);



const config = {

    db: {
      /* don't expose password or any sensitive info, done only for demo */
      host: "db4free.net",
      user: "sunandplay",
      password: "sunandplay",
      database: "sunandplay",
    },
    listPerPage: 1000,
    
};

module.exports = config;


const options = {
    method : 'GET',
    headers : { 'content-type' : 'application/json' },
    data : 
        {
            value : 10
        },
    url : "http://localhost:3001/data"
}


Axios.get("http://localhost:3001/data", {value: 10}).then((response) => {
    console.log(response.data.data.slice(0,10));
});


props.tachasAllData.forEach((tacha) => {

    let tempTemps = [];
    let tempHums = [];
    let tempAcels = [];

    tacha.forEach(record => {
        tempTemps.push(record.temperatura);
        tempHums.push(record.humedad);
        tempAcels.push(record.aceleracion);
    });

    props.infoTachas[tacha.id].lastTemps.push(tempTemps);
    props.infoTachas[tacha.id].lastHums.push(tempHums);
    props.infoTachas[tacha.id].lastAcels.push(tempAcels);

});


props.tachasAllData[tacha.id].forEach((record) => {
    console.log(record.temperatura);
    // props.infoTachas.lastTemps.push(record.temperatura)
    // props.infoTachas.lastHums.push(record.humedad)
    // props.infoTachas.lastAcels.push(record.aceleracion)
})

try {
    setInterval(async () => {
    let tachasAllData = [];
    for (let i = 0; i < 21; i++) {
        Axios.get(`http://localhost:3001/data/${i}`).then((response) => {insertAt(tachasAllData, i, response.data.data.slice(0,100))});
    }
    this.setState({ tachasAllData : tachasAllData })
    }, 10000);
} catch(e) {
    console.log(e);
}


async function getMultiple(page = 1, id){

  const offset = helper.getOffset(page, config.listPerPage);
  const rows = await db.query(
    `SELECT id, temperatura, humedad, aceleracion
    FROM tacha_${id} LIMIT ${offset},${config.listPerPage}`
  );
  const data = helper.emptyOrRows(rows);
  //const meta = {page};

  return {
    data,
    //meta
  }
}

(response) => {console.log(response.data.data[0]);}


l[0].split(',').forEach(id => {

    let rangos = id.split('-')   
    let rango_inf = Number(rangos[0]);
    let rango_sup = Number(rangos[1]);
    let margen = rango_sup - rango_inf;
    let ids = [];  

    if (rangos.length === 1) {
        set(ref(db, 'downlink/' + rangos[0]), {
            color : color
        });
    }
    else {
        for (let i = 0; i <= margen; i++) {
            ids.push(String(rango_inf + i));
            set(ref(db, 'downlink/' + ids[i]), {
                color : color
            });
        }
    }
})
}



set(ref(db, 'downlink/' + rangos[0]), {
    color : color
});


import { Link } from "react-router-dom";
import classes from './Graph.module.css';
import GlobalLineChartPlot from "../Graphs/GlobalLineChartPlot";
import GlobalScatterChartPlot from "../Graphs/GlobalScatterChartPlot";
import GlobalVerticalBarPlot from "../Graphs/GlobalVerticalBarPlot";
import GlobalBubbleChartPlot from "../Graphs/GlobalBubbleChartPlot";

const Graphs = () => {

    return(

        <div className={classes.MainDiv}>

            <div className={classes.Link}>
                <Link to="/" style={{ textDecoration: 'none' }}>Página principal</Link>
            </div>

            <div className={classes.Fila}>

                <div className={classes.Plots}>
                    <GlobalLineChartPlot></GlobalLineChartPlot>
                </div>

                <div className={classes.Plots}>
                    <GlobalScatterChartPlot></GlobalScatterChartPlot>
                </div>

            </div>

            <div className={classes.Fila}>

                <div className={classes.Plots}>
                    <GlobalVerticalBarPlot></GlobalVerticalBarPlot>
                </div>

                <div className={classes.Plots}>
                    <GlobalBubbleChartPlot></GlobalBubbleChartPlot>
                </div>

            </div>

        </div>

    )
}

export default Graphs;




async function getMultiple(page = 1, parametro, id){

  //const offset = helper.getOffset(page, config.listPerPage);
  //LIMIT ${offset},${config.listPerPage}

  const rows = await db.query(
    `SELECT * FROM ${parametro} WHERE id = ${id}`
  );
  const data = helper.emptyOrRows(rows);
  //const meta = {page};

  return {
    data,
    //meta
  }
}


import axios from 'axios';

const getData = (parametro, id) => {

    let dates = [];
    let values = [];

    axios.get(`http://localhost:3001/data/${parametro}/${id}`).then((response) => {

        let data  = response.data.data[0];


        for (var key in data) {
            if (data.hasOwnProperty(key)){
                if (key !== 'id') {
                    dates.push(key);
                    values.push(data[key]);
                }
            }
        }
    });

    return [dates, values];
}

export default getData;

import getData from "../components/getData";

const obtenerDatos = () => {
    const numTachas = 21;
    let labels = [];
    let temps = [];
    let hums = [];
    let acels = [];

    const randomColor = () => {
    return Math.floor(Math.random()*16777215).toString(16);
    }

    labels.push(getData('M_Temperatura', 1)[0]);

    ['M_Temperatura', 'M_Humedad', 'M_Aceleracion'].forEach((param) => {

        for (let m = 1; m <= numTachas; m++) {
            if (param === 'M_Temperatura') {
                temps.push({ 
                    data : getData(param, m)[1],
                    label : `Tacha ${m}`,
                    borderColor : '#' + randomColor(),
                    backgorundColor : '#' + randomColor()
                });
            }
            if (param === 'M_Humedad') {
                hums.push({ 
                    data : getData(param, m)[1],
                    label : `Tacha ${m}`,
                    borderColor : '#' + randomColor(),
                    backgorundColor : '#' + randomColor()
                });
            }
            if (param === 'M_Aceleracion') {
                acels.push({ 
                    data : getData(param, m)[1],
                    label : `Tacha ${m}`,
                    borderColor : '#' + randomColor(),
                    backgorundColor : '#' + randomColor()
                });
            }
        }
    })

    return [labels[0], temps, hums, acels];

}

export default obtenerDatos;



import axios from 'axios';
import { useEffect, useState } from 'react';
import LineChartPlot from "../Graphs/LineChartPlot";
import classes from '../Graphs/Plot.module.css'

const GetData = (props) => {

    const [isLoading, setLoading] = useState(true);
    const [data, setData] = useState([]);
    const [labels, setLabels] =  useState([]);

    useEffect(() => {

        const interval = setInterval(() => {

            axios.get(`http://localhost:3001/data/${props.parametro}/${props.id}`).then((response) => {

                for (var key in response.data.data[0]) {
                    if (response.data.data[0].hasOwnProperty(key)){
                        if (key !== 'id') {
                            setLabels(labels => [...labels, key])
                            setData(data => [...data, response.data.data[0][key]])
                        }
                    }
                }

                setLoading(false)

            });

        }, 240000);

        return () => {clearInterval(interval)};

    }, [props.parametro, props.id]);

    if (isLoading) {
        return(
            <div className={classes.LinePlot}>
                Cargando datos...
            </div>
        ) 
    }

    return(
        <LineChartPlot
            id={props.id}
            data={data.slice(-10)}
            labels={labels.slice(-10)}
            varName={props.varName}
            borderColor={props.borderColor}
            backgroundColor={props.backgroundColor}>
        </LineChartPlot>
    )

}

export default GetData;


const randomColor = () => {
  return '#' + Math.floor(Math.random()*16777215).toString(16);
}


        for (var key in response.data.data[0]) {
            if (response.data.data[0].hasOwnProperty(key)){
                if (key !== 'id') {
                  labels.push(key);
                  datasets.push(response.data.data[0][key])
                }
            }
        }


    const data = {
        labels,
        datasets: [

        {
            label: 'Valor',
            data: props.data,
            borderColor: props.borderColor,
            backgroundColor: props.backgroundColor,
        },

        ],
    };

  for (var tacha in refresh()[1]) {
    data.datasets.push({
        label: 'Valor',
        data: refresh()[1][tacha],
        borderColor: randomColor(),
        backgroundColor: randomColor(),
    })
  }


import { Chart as ChartJS, CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend } from 'chart.js';
import { useState, useEffect } from 'react';
import axios from 'axios';
import classes from './LineChartGlobal.module.css';
import { Line } from 'react-chartjs-2';

ChartJS.register( CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend );

const randomColor = () => {
  return '#' + Math.floor(Math.random()*16777215).toString(16);
}

const GlobalLineChartPlot = (props) => {

  const [isLoading, setLoading] = useState(true);
  let title = '';
  let parametro = '';
  let datasets = [];
  let labels = [];

  if (props.tempSel) {
    title = 'Temperatura tachas instaladas';
    parametro = 'M_Temperatura';
  }
  if (props.humSel) {
    title = 'Humedad tachas instaladas';
    parametro = 'M_Humedad';
  }
  if (props.acelSel) {
    title = 'Aceleración tachas instaladas';
    parametro = 'M_Aceleracion';
  }

  const refresh = () => {

    axios.get(`http://localhost:3001/data/${parametro}/1/true/${props.inicioTachas}/${props.finalTachas}`).then((response) => {

      for (var tacha in response.data.data) {
        let dataset = [];
        let labelsTacha = [];
        for(var key in response.data.data[tacha]) {
          if (response.data.data[tacha].hasOwnProperty(key)){
            if (key !== 'id') {
              labelsTacha.push(key)
              dataset.push(response.data.data[tacha][key])
            }
          }
        }
        labels.push(labelsTacha);
        datasets.push(dataset);
      }

      setLoading(false);

    })

  };

  useEffect(refresh, [props.id, parametro, props.inicioTachas, props.finalTachas, props.inicioFecha, props.finalFecha]);

  const options = {

    responsive: true,

    plugins: {
    title: {
        display: true,
        text: title
    },
    legend: { display: false }
    },

    maintainAspectRatio: false

  };

  //const labels = [];

  if (isLoading) {
      return(
          <div className={classes.LinePlot}>
              <h1 className={classes.h1}>
                  Cargando datos ...
              </h1>
          </div>
      ) 
  }

  return(
    <div className={classes.LinePlot}>
      <Line options={options} data={}></Line>
      <button onClick={refresh}>
        Actualizar datos
      </button>
    </div>
  )

}

export default GlobalLineChartPlot;



const refresh = (parametro, offset, limit) => {

  let datasets = [];
  let labels = [];

  axios.get(`http://localhost:3001/data/${parametro}/1/true/${offset}/${limit}`).then((response) => {

    for (var tacha in response.data.data) {
      let dataset = [];
      let labelsTacha = [];
      for(var key in response.data.data[tacha]) {
        if (response.data.data[tacha].hasOwnProperty(key)){
          if (key !== 'id') {
            labelsTacha.push(key)
            dataset.push(response.data.data[tacha][key])
          }
        }
      }
      labels.push(labelsTacha);
      datasets.push(dataset);
    }
  })

  return [datasets, labels[0]]

};